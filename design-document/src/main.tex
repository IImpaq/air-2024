%! Author = marcus
%! Date = 04.11.24

\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}

\geometry{margin=2.5cm}

\begin{document}

  \begin{titlepage}
    \begin{center}
      \vspace*{2cm}
      {\huge\bfseries Project Title\par}
      \vspace{2cm}
      {\Large Group Number: X\par}
      \vspace{1.5cm}
      {\large\bfseries Group Members:\par}
      \vspace{0.5cm}
      {\large
      Name 1 (Role)\par
      Name 2 (Role)\par
      Name 3 (Role)\par
      Name 3 (Role)\par
      }
      \vfill
      {\large \today\par}
    \end{center}
  \end{titlepage}

  \tableofcontents
  \newpage

  \section{Abstract}

  \section{Idea}

  In today’s world, the sheer volume of content available is overwhelming.
  It’s challenging for many to find movies they genuinely want to watch amidst a sea of irrelevant material.
  Streaming providers and online distributors possess the potential to curate a concise selection for their users.
  However, many of them choose not to do so.
  The reasons behind this decision remain unclear, but it’s possible that it’s a strategy to keep users locked into their platforms for as long as possible.
  Instead of offering users a curated selection, they’re presented with a flood of mediocre content that’s nowhere near what they’re truly interested in.
  Our mission is to value the time of users by making it easier for them to watch the movies they genuinely want to see.
  To achieve this, we’re building a platform where users can explicitly define their movie preferences, whether it’s general tastes or specific preferences for the moment.
  The system then diligently searches through a vast movie database to find an appropriate and concise selection that aligns with the user’s criteria.
  The top results are presented to the user with brief descriptions of the movie’s content, genre, actors, release date, and title.
  If the user isn’t satisfied with the provided content, the system adapts and re-searches the database using the modified criteria.
  Alternatively, if the user finds a movie they enjoy, we strive to minimize the barriers to starting a movie by directly recommending a few services that offer the selected content.
  With a single click, users can seamlessly switch to their favorite streaming platform, stream or purchase the movie, and enjoy it without any hassle.

  \subsection{Goal}
  Our mission is to value human time by simply recommending movies they genuinely want to watch, without forcing them to sift through a catalog of irrelevant content.
  The demand for such a service will only increase over time as the number of movies and series created continues to grow exponentially.
  In fact, there are now more TV shows produced in a given period than ever before, and this trend appears to persist.

  \section{Main Task}

  Our primary objective is to design an advanced information retrieval system for movie recommendations, employing a transformer-based architecture.
  To accomplish this, our core component will comprise a fusion of transformer models, including:
  \begin{itemize}
    \item to perform text encoding
    \item for text summarization
    \item as a sentence transformer for semantic similarity
  \end{itemize}

  \noindent Technically, the retrieval pipeline will work approximately as follows:
  \begin{itemize}
    \item Processing the user’s query, capturing their preferences.
    \item Document encoding of the movie preferences retrieved from the dataset.
    \item Calculating the similarity between the encoded user query and the encoded movie document.
    \item Ranking the results based on their relevance to the user.
  \end{itemize}

  \noindent After the initial phase of the retrieval pipeline concludes, the user has the option to assess their satisfaction with the results or to disregard irrelevant recommendations.
  If a selection of irrelevant content is made, the system will adapt and present a new selection based on the evolving user preferences.
  This approach aims to deliver the highest quality recommendations while minimizing the user’s effort.

  \section{Dataset and Processing}

  This section goes into detail regarding the sources of used data, as well as how such data is processed.

  \subsection{Data Sources}

  We are using the ``wykonos/movies'' dataset as our movie database.
  It is loaded through Hugging Face.
  The data set contains the following features:
  id, title, genre, original language, overview, popularity, production companies, release date, budget / revenue, runtime, status, tagline, vote (avg) \& vote (count), credits, keywords.

  We also need a provider for the captions/subtitles such that we can generate an informative summarization/recommendation based on the actual content of the movie.
  This provider will be contacted and their data fetched through the backend of the system.
  Such a feature should be easily implementable using a simple REST-API.
  We are, at the time of writing this document, still searching for a cheap/free option to fullfill this requirement. (TODO)

  \subsection{Data Processing}

  Before using the dataset we need to pre-process it.
  This is done through a data ``cleaning'' step.
  During this procedure, the missing values (NaN) are replaced with empty strings to avoid future issues.
  In the next step, each of the entries in the dataset is converted to strings.

  \section{Methods and Models}

  This section tries to explain a technical deep dive of how our previously defined IR problem will be solved.

  \subsection{System Architecture}

  TODO

  \subsection{Implementation}

  The whole backend of the system will be implemented using python.
  There are many useful libraries and tools which are helpful to work on the given problem, examples include but are not limited to: pytorch, pandas, numpy, scipy.
  The first step is to perform the required input processing (encoding).
  For that, an optimized transformer model will be used.
  Afterwards, using the model generated using the tokenized input, we use mean pooling of the last hidden states for similarity computation later on.
  Additionaly to the user input, also the the movie descriptions must be encoded.
  This then allows for computation of a similarity measurement between user input and movie description (e.g. cosine similarity).
  To provide the user only with the most relevant recommendations, a sophisticated ranking mechanism based on the similarity scores will be applied.
  Now only the top 3 results, enriched using a variety of additional movie metadata and a summary/recommendation of the content can be shown to the user.
  To provide the user with the summary we must first make a request to a caption/subtitle provider and then use the returned data in a summerization pipeline with an apprioriate model.
  The recommendation will then be visualized in the frontend which will be implemented using a modern web technology stack, including but not limited to: NextJS.
  The recommendation can then be evaluated by the user and in the case of dissatisfaction be re-evaluated by the model to update the recommendation using a selection of irrelevant movies by the user.

  \subsection{Optimization questions}
  Due to the size of the dataset a variety of optimization questions come to mind.
  This includes topics like memory management strategies, increased scalability using batch processing and hardware acceleration (CUDA/MPS)

  \section{Evaluation}
  \subsection{Metrics}

  \subsection{Results}

  \subsection{Discussion}


\end{document}
